//定义
//        归并排序（merge sort）是高效的基于比较的稳定排序算法。
//归并排序(Merge Sort)是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法(Divide and Conquer)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
//
//它采用分治的思想来将一个大问题分解为多个小问题，并通过合并已排序的子问题来解决原始问题。
//
//归并排序的时间复杂度是O(nlogn)，其中n是待排序数组的大小。它是一种稳定的排序算法，适用于各种不同类型的数据。
//
//归并排序的优点是它具有良好的稳定性和可预测性，而且在处理大型数据集时也表现良好。然而，它需要额外的空间来存储临时数组，因此在空间有限的情况下可能不是最佳选择。
//
// 步骤
//
//1、分离
//        将已有数列不断分离成两段长度基本相同（当已有数列长度是奇数时，则一半长一半短），直到分离成长度为 1 的 n 个数列（其实就是 n 个数）。
//
//2、合并
//        将两个已排序的子数组合并为一个新的已排序数组。合并操作通过比较两个子数组的元素，并按照顺序将它们逐个放入新数组中。
//
//3、递归
//        对每个子数组重复上述两个步骤，直到所有子数组都被合并为一个完整的已排序数组。
//
//性质
//        归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 O(nlogn)，空间复杂度为 O(n)。
//
//归并排序可以只使用O(1)的辅助空间，但为便捷通常使用与原数组等长的辅助数组。

#include <iostream>
using namespace std;
int n=9,b[9];
int a[9] = {8,2,6,3,9,4,1,7,5};

//归并
//low 和 mid 分别是要合并的第一个数列的开头和结尾，mid+1 和 high 分别是第二个数列的开头和结尾
void merge(int low,int mid,int high){
    //i、j 分别标记第一和第二个数列的当前位置，k 是标记当前要放到整体的哪一个位置
    int i=low,j=mid+1,k=low;
    //如果两个数列的数都没放完，循环
    while (i<=mid && j<=high){
        //将a[i] 和 a[j] 中小的那个放入 b[k]，然后将相应的标记变量增加
        if (a[i]<a[j]){
            b[k++]=a[i++];
        }else{
            b[k++]=a[j++];
        }
    }
    //当有一个数列放完了，就将另一个数列剩下的数按顺序放好
    while (i<=mid){
        b[k++]=a[i++];
    }
    while (j<=high){
        b[k++]=a[j++];
    }
    //将 b 数组里的东西放入 a 数组，因为 b 数组还可能要继续使用
    for (int i=low;i<=high;i++){
        a[i]=b[i];
    }
}

//分离
//x 和 y 分别代表要分离数列的开头和结尾
void mergeSort(int x, int y){
    //如果开头 ≥ 结尾，那么说明数列分完了，就要返回
    if (x>=y) {
        return;
    }
    //将中间数求出来，用中间数把数列分成两段
    int mid=(x+y)/2;
    //递归，继续分离
    mergeSort(x, mid);
    mergeSort(mid + 1, y);
    //分离完之后就合并
    merge(x,mid,y);
}
int main(){
    mergeSort(1, n);
    for (int i=1;i<=n;i++){
        cout <<a[i] <<" ";
    }
    return 0;
}
